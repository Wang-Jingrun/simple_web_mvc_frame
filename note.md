# 一、Linux 网络编程基础 API
## 1.socket地址API
### 主机字节序和网络字节序
一个32位计算机的CPU累加器一次能累加4字节的数据，而这4字节的数据在内存中排列的顺序是可以有2种方式的，即大端字节序和小端字节序

- 大端字节序：一个整数的高位字节（23~31bit）存储在内存的低地址处
- 小端字节序：一个整数的低位字节（0 ~ 7 bit）存储在内存的低地址处

由于不同的主机使用的字节序可能不同，因此两个主机之间发送数据可能会发生错误。解决方法是：制定一个规范：**发送端统一使用大端字节序（因此大端字节序称为网络字节序）而因为现代PC大多采用小端字节序，因此小端字节序称为主机字节序**


Linux中实现主机字节序和网络字节序的函数：

```cpp
#include<netinet/in.h>
unsigned long int htonl(unsigned long int hostlong);
unsigned short int htons(unsigned short int hostshort);
unsigned long int ntohl(unsigned long int netlong);
unsigned short int ntohs(unsigned short int netshort);
```

其作用可以通过名字理解，比如 htonl :" host to network long" ，即长整型的主机字节序转换成网络字节序。这四个函数中long类型的函数一般用来转换IP地址，short类型的一般用来转换端口号（操作系统基础知识）

### 通用socket地址

主机之间的通信需要知晓对方的地址，而网络中主机的地址是TCP/IP协议族来定义的（计算机网络基础知识），在Linux网络编程中，通过使用socket的这个套接字来进行网络通信。socket定义了一系列的API实现网络通信，是非常方便好用的工具。

在socket网络编程中表示地址的是结构体`sockaddr`，但由于这个结构体的设计问题，无法容纳多数协议族的地址值，因此Linux定义了一个新的通用socket地址结构体

```cpp
#include<bits/socket.h>
struct sockaddr_storge
{
    sa_family_t sa_family;
    unsigned long int __ss_align;
    char__ss_padding[128-sizeof(__ss_align)];
}
```

###  专用socket地址

以上两种通用socket地址其实并不好用，所以Linux为各个协议族提供了专门的socket地址结构体

其中，UNIX本地协议族使用`sockaddr_un`，而TCP/IP协议族使用`sockaddr_in`和`sockaddr_in6`两个分别对应IPv4和IPv6

![img](imgs/c43049c6f9d14d3c97c90f34110d99d2.png)

但需要注意的是，使用`sockaddr_in`或其他专用socket地址（包括`socket_storge`)，最后都要**强制转换**成通用socket地址类型`sockaddr`，这是**因为所有socket编程接口使用的地址参数的类型都是`sockaddr`**

## 2.创建socket

> ```cpp
> int socket(int domain,int type,int protocol);
> ```
> 功能：用于创建一个套接字（socket）的系统调用
>
> 参数：
>
> - domain：协议族
> 	- AF_INET：IPv4
> 	- AF_INET6: IPv6
> 	- AF_UNIX，AF_LOCAL：本地套接字通信
> - type：通信过程中使用的协议类型
> 	- SOCK_STEAM：流式协议(传输层使用TCP协议）
> 	- SOCK_DGRAM：数据报式协议（传输层使用UDP协议）
> - protocol 指定套接字使用的具体协议。在指定协议族和套接字类型后，通常会使用 0 作为协议参数，让系统根据前两个参数的取值自动选择合适的协议。对于特定的协议，可以指定具体的协议号，如 `IPPROTO_TCP`、`IPPROTO_UDP` 等。
>
> 返回值：如果套接字创建成功，则返回一个非负整数值，用于后续的套接字操作。如果创建套接字失败，返回-1，并设置全局变量 `errno` 表示具体的错误类型。可以通过一下方式打印出错误信息：
>
> ```cpp
> printf("socket error: errno=%d errmsg=%s\n", errno, strerror(errno));
> ```

创建socket的代码

```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <cstring>
#include <string>
using std::string;

// 1、创建 socket
int sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```

## 3.绑定socket（bind)

在创建套接字时，通过指定协议族（例如，IPv4 `AF_INET` 或 IPv6 `AF_INET6`）来确定套接字使用的地址族。但是，并没有指定具体使用该地址族中的哪个具体地址。

要为套接字指定具体的地址，需要使用系统调用 `bind()`将套接字与特定的 IP 地址和端口号绑定在一起，以便服务端能够监听该地址上的连接。这样，当客户端发起连接时，服务端就能接受并处理连接请求。

**注**：而对于客户端，通常采用匿名绑定（anonymous bind），也就是不需要显式调用 `bind()`。在客户端创建套接字后，操作系统会自动为其分配一个临时的本地地址，并将其与套接字关联起来。这样，客户端在发起连接时，操作系统会使用该临时地址作为源地址，与服务端进行通信。

> ```cpp
> int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);
> ```
>
> 功能：将套接字与指定的地址绑定起来。
>
> 参数：
>
> - `sockfd`：要绑定地址的套接字描述符。
> - `my_addr`：指向要绑定的地址结构体的指针。根据套接字的地址族不同，可以是 `struct sockaddr_in`（IPv4）或 `struct sockaddr_in6`（IPv6）。
> - `addrlen`：`my_addr` 结构体的长度。
>
> 返回值：成功绑定返回0，失败返回-1，并设置全局变量 `errno` 表示具体的错误类型。

绑定过程：

```cpp
// 2、绑定 socket
string ip = "127.0.0.1";
int port = 8080;
struct sockaddr_in sockaddr;
std::memset(&sockaddr, 0, sizeof(sockaddr)); // 参数重置为 0
sockaddr.sin_family = AF_INET;
sockaddr.sin_addr.s_addr = inet_addr(ip.c_str()); // 使用网络统一的编码
sockaddr.sin_port = htons(port); // 使用网络统一的编码
bind(sockfd, (struct sockaddr*)&sockaddr, sizeof(sockaddr)); // sockaddr_in 强制转换为 sockaddr
```

其中，`inet_addr`用于将点分十进制形式的 IP 地址转换为32位无符号整数形式的网络字节序（大端字节序）的IP地址。

## 4.监听socket（listen）

> ```cpp
> int listen(int sockfd, int backlog);
> ```
>
> 功能：将套接字设置为监听模式，准备接受连接请求。
>
> 参数：
>
> - `sockfd`：要设置为监听模式的套接字描述符。
> - `backlog`：等待连接队列的最大长度，未连接的和已经连接的和的最大值。
>
> 返回值：成功返回0，失败返回-1，并设置全局变量 `errno` 表示具体的错误类型。

监听过程：

```cpp
listen(sockfd, 1024);
```

## 5.接收连接——服务端（accept）

有了一个监听socket（执行过listen调用，处于LISTEN状态的socket），就可以进行通信。而最后一步，就是将监听队列中的一个socket取出来，即可与远端的主机进行读写交互了。

> ```cpp
> int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
> ```
>
> 功能：接受客户端的连接请求，并创建一个新的套接字来与客户端进行通信。
>
> 参数：
>
> - `sockfd`：监听套接字描述符，即之前通过 `socket()` 和 `bind()` 设置为监听模式的套接字。
> - `addr`：用于存储客户端的地址信息。可以传入 `nullptr`，表示不关心客户端的地址信息。
> - `addrlen`：用于指定 `addr` 缓冲区的大小。同样，通过传入 `nullptr`，表示不关心客户端的地址信息的长度。
>
> 返回值：如果成功接受连接请求，则返回一个新的套接字描述符，用于与客户端进行通信。如果出现错误，返回-1，并设置全局变量 `errno` 表示具体的错误类型。

接收连接过程（通常在一个 `while(true)` 循环中）：

```cpp
// 4、接收客户端连接
int connfd = ::accept(sockfd, nullptr, nullptr);
```

## 6.发起连接——客户端（connect）

绑定socket，监听socket和接受连接都是服务端要干的事，在服务端创建好了监听队列后，就可以接受来自客户端的连接请求。客户端通过`connect`发起连接请求。

> ```
> int connect(int sockfd, const struct sockaddr* serv_addr, socklen_t addrlen);
> ```
>
> 功能：与指定的服务器建立连接。
>
> 参数：
>
> - `sockfd`：套接字描述符，用于标识本地套接字。
> - `serv_addr`：指向目标服务器地址的指针。可以是 `struct sockaddr_in` 或 `struct sockaddr_in6`，取决于使用的 IP 地址类型。
> - `addrlen`：指定 `serv_addr` 缓冲区的大小。
>
> 返回值：如果连接成功建立，返回 0；如果出现错误，返回 -1，并设置全局变量 `errno` 表示具体的错误类型。

发起连接过程：

```cpp
// 2、连接服务端
string ip = "127.0.0.1";
int port = 8080;
struct sockaddr_in sockaddr;
std::memset(&sockaddr, 0, sizeof(sockaddr)); // 参数重置为 0
sockaddr.sin_family = AF_INET;
sockaddr.sin_addr.s_addr = inet_addr(ip.c_str()); // 使用网络统一的编码
sockaddr.sin_port = htons(port); // 使用网络统一的编码
connect(sockfd, (struct sockaddr*)&sockaddr, sizeof(sockaddr); // sockaddr_in 强制转换为 sockaddr
```

## 7.关闭连接（close）

通信完成后，如要关闭连接，可以通过下面的系统调用

> ```cpp
> int close(int fd);
> ```
>
> 功能：关闭指定的文件描述符。
>
> 参数：
>
> - `fd`：要关闭的文件描述符。
>
> 返回值：成功关闭文件描述符返回 0，失败返回 -1，并设置全局变量 `errno` 表示具体的错误类型。

关闭连接：

```cpp
close(sockfd);
```

## 8.数据收发（send, recv）

在进行 socket 通信期间，连接建立成功后，可以进行两个主机之间的通信。对于 TCP 协议，可以使用 `recv()` 和 `send()` 函数进行数据收发。

> ```cpp
> ssize_t recv(int sockfd, void* buf, size_t len, int flags);
> ssize_t send(int sockfd, const void* buf, size_t len, int flags);
> ```
>
> 功能：进行数据读写操作。
>
> 参数：
>
> - `sockfd`：用于通信的文件描述符，即套接字描述符。
> - `buf`：数据缓冲区的位置，即存储读取或发送数据的内存地址。
> - `len`：缓冲区的大小，即期望读取或发送的数据长度。
> - `flags`：通常取 0，表示没有特殊的控制标志，其他取值可以进行具体的控制，具体含义可以查阅相关文档或资料。
>
> 返回值：
>
> - 成功：
>   - `recv()`：返回实际读取到的数据的长度。如果返回值小于期望长度 `len`，可能是缓冲区中没有足够的数据，可以多次调用 `recv()` 进行读取。
>   - `send()`：返回实际成功写入的数据长度。
> - 失败：返回 -1，并设置全局变量 `errno` 表示具体的错误类型。

收发过程：

```cpp
// 5、接收客户端的数据
char buf[1024] = { 0 };
size_t len = ::recv(connfd, buf, sizeof(buf), 0);
printf("recv: connfd=%d msg=%s\n", connfd, buf);

// 6、向客户端发送数据
::send(connfd, buf, len, 0); // 原数据返回给客户端
```

# 二、高级I/O函数

## 1.pipe函数

> ```cpp
> #include <unistd.h>
> int pipe(int fd[2]);
> ```
>
> 功能：用于创建一个**半双工的**管道，用于实现具有亲缘关系的进程之间的通信。管道由操作系统创建，并为调用进程分配一个读取端和一个写入端的文件描述符。通过这两个文件描述符，亲缘关系的进程可以在管道中进行双向的数据传输。
>
> 参数：
> - `fd`：整型数组，长度为2
> 	- `fd[0]`: 从管道中读出的文件描述符
> 	- `fd[1]`: 往管道中写入的文件描述符
> 	- 1是写0是读，先1后0
>
> 返回值：
> - 成功创建返回0，失败：返回-1。
>

## 2.dup函数和dup2函数

> ```cpp
> #include <unistd.h>
> int dup(int file_descriptor);
> ```
>
> 功能：用于复制文件描述符 `file_descriptor`，并返回新的文件描述符。
>
> 参数：
> - file_descriptor：要复制的文件描述符。
>
> 返回值：
> - 成功复制返回新的文件描述符，失败返回-1。

> ```cpp
> #include <unistd.h>
> int dup2(int file_descriptor_one, int file_descriptor_two);
> ```
>
> 功能：用于将源文件描述符 `file_descriptor_one` 复制到目标文件描述符 `file_descriptor_two`。如果目标文件描述符 `file_descriptor_two` 已经打开，则会先关闭它，然后将源文件描述符复制到目标文件描述符。
>
> 参数：
> - file_descriptor_one：源文件描述符。
> - file_descriptor_two：目标文件描述符。
>
> 返回值：
> - 成功返回目标文件描述符的值，失败返回-1

## 3.readv函数和writev函数

> ```cpp
> #include <sys/uio.h>
> ssize_t readv(int fd, const struct iovec* vector, int count);
> ```
>
> 功能：将文件描述符内的数据**分散读**到的内存块中
>
> 参数：
>
> - `fd`：要读取的文件描述符。
> - `vector`：指向 `iovec` 结构体数组的指针，每个结构体描述一个缓冲区的地址和长度。
> - `count`：`iovec` 结构体数组的元素个数。
>
> 返回值：
>
> - 成功返回实际读取的字节数，失败返回-1。

> ```cpp
> #include <sys/uio.h>
> ssize_t writev(int fd, const struct iovec* vector, int count);
> ```
>
> 功能：将分散的内存中数据**集中写**到文件描述符中。
>
> 参数：
>
> - `fd`：要写入的文件描述符。
> - `vector`：指向 `iovec` 结构体数组的指针，每个结构体描述一个缓冲区的地址和长度。
> - `count`：`iovec` 结构体数组的元素个数。
>
> 返回值：
>
> - 成功返回实际写入的字节数，失败返回-1。

HTTP应答可以用 writev 函数实现

## 4.sendfile函数

> ```cpp
> #include <sys/sendfile.h>
> ssize_t sendfile(int out_fd, int in_fd, off_t offset, size_t count);
> ```
>
> 功能：在两个文件描述符之间直接传输数据，而无需将数据从内核空间复制到用户空间，从而提高数据传输的效率。它通常用于在网络编程中将文件数据发送到套接字，或者在文件之间进行数据传输。
>
> 参数：
>
> - `out_fd`：目标文件描述符，数据将被传输到此文件描述符。
> - `in_fd`：源文件描述符，数据将从此文件描述符读取。
> - `offset`：源文件的偏移量，表示从源文件的哪个位置开始读取数据。
> - `count`：要传输的数据的大小，以字节数表示。
>
> 返回值：
>
> - 成功传输返回实际传输的字节数，返回-1。

## 5.mmap函数和munmap函数

> ```cpp
> #include <sys/mman.h>
> void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);
> ```
>
> 功能：将文件或者设备映射到进程的内存空间中，从而使得进程可以通过内存访问文件或者设备的内容。即申请一块进程间进行通信的共享内存。
>
> 参数：
>
> - `start`：映射的起始地址，通常设置为 `NULL`，由系统自动选择合适的地址。
> - `length`：映射的长度，以字节为单位。
> - `prot`：内存保护模式，指定内存区域的访问权限，包括 `PROT_NONE`、`PROT_READ`、`PROT_WRITE` 和 `PROT_EXEC` 等。
> - `flags`：映射的标志，控制映射的特性，包括 `MAP_SHARED`、`MAP_PRIVATE`、`MAP_FIXED` 等。
> - `fd`：要映射的文件描述符，或者是 `MAP_ANONYMOUS` 标志用于映射匿名内存。
> - `offset`：映射的文件偏移量，表示从文件的哪个位置开始映射，对于匿名内存映射可设置为 0。
>
> 返回值：
>
> - 成功返回映射区的起始地址，返回 `MAP_FAILED`（-1）。

> ```cpp
> #include <sys/mman.h>
> int munmap(void* start, size_t length);
> ```
>
> 功能：用于解除对内存区域的映射，使得该内存区域不再与文件或设备关联。解除映射后，进程将无法继续访问和操作这部分内存。
>
> 参数：
>
> - `start`：要解除映射的起始地址。
> - `length`：要解除映射的长度，以字节为单位。
>
> 返回值：
>
> - 成功返回0，失败返回-1。

## 6.splice函数

> ```cpp
> #include <fcntl.h>
> ssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);
> ```
>
> 功能：两个文件描述符之间**零拷贝**地移动数据（类似ctrl+x -> ctrl+v)
>
> 参数：
>
> - `fd_in`：源文件描述符，从该文件描述符读取数据。
> - `off_in`：源文件的偏移量指针，表示从源文件的哪个位置开始读取数据。可以为 `NULL`，表示从当前位置开始读取。
> - `fd_out`：目标文件描述符，将数据传输到该文件描述符。
> - `off_out`：目标文件的偏移量指针，表示将数据写入目标文件的哪个位置。可以为 `NULL`，表示从当前位置开始写入。
> - `len`：要传输的数据的长度，以字节数表示。
> - `flags`：传输标记，控制传输的行为，例如 `SPLICE_F_MOVE`、`SPLICE_F_NONBLOCK` 等。
>
> 返回值：
>
> - 成功：返回实际传输的字节数，返回-1。

一般两个splice函数成对使用，一个往管道里写，一个从管道里读

## 7.tee函数

> ```cpp
> #include <fcntl.h>
> ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);
> ```
>
> 功能：在两个文件描述符之间复制数据，不绕过用户空间。（类似ctrl+c -> ctrl+v）
>
> 参数：
>
> - `fd_in`：源文件描述符，从该文件描述符读取数据。
> - `fd_out`：目标文件描述符，将数据复制到该文件描述符。
> - `len`：要复制的数据的长度，以字节数表示。
> - `flags`：复制标记，控制复制的行为，例如 `O_NONBLOCK` 等。
>
> 返回值：
>
> - 成功返回实际复制的字节数，失败返回-1。

调用 `tee` 函数后，数据将从源文件描述符读取到用户空间缓冲区，然后再从用户空间缓冲区复制到目标文件描述符。这种复制方式涉及用户空间和内核空间之间的数据拷贝，效率相对较低。与 `splice` 函数相比，`tee` 函数的主要优点是可以在复制过程中查看数据，而不仅仅是传输到目标文件描述符。

## 8.fcntl函数

> ```cpp
> #include <fcntl.h>
> int fcntl(int fd, int cmd, ...);
> ```
>
> 功能：对一个文件描述符进行各种控制操作（如：将其设置为非阻塞等）
>
> 参数：
>
> - `fd`：要进行控制操作的文件描述符。
> - `cmd`：控制命令，指定要执行的操作类型。
> - `...`：可变参数，根据不同的控制命令可能需要提供其他参数。
>
> 返回值：
>
> - 根据不同的控制命令，返回不同的值或执行状态。
>
> `fcntl` 函数用于对文件描述符执行各种控制操作。它可以用于修改文件描述符的属性、获取文件描述符相关的信息、执行各种 I/O 操作等。
>
> 具体的操作由 `cmd` 参数指定，它决定了要执行的操作类型。`cmd` 可以取以下一些常见的值：
>
> - `F_DUPFD`：复制文件描述符。
> - `F_GETFD`：获取文件描述符的标志值。
> - `F_SETFD`：设置文件描述符的标志值。
> - `F_GETFL`：获取文件状态标志。
> - `F_SETFL`：设置文件状态标志。
> - `F_GETLK`：获取文件记录锁。
> - `F_SETLK`：设置文件记录锁。
> - `F_SETLKW`：设置文件记录锁，如果锁不可用则等待。

# 三、Linux服务器程序框架

## 1.服务器编程基础框架

### C/S模型
TCP/IP的最初设计理念并没有客户端和服务端的概念，主机与主机之间大多进行的是信息对等交换。

*类似于人类古代的以物易物的交易方式*

但随着网络的发展，有一些主机其掌握了更多的资源，其他主机想要获得资源都要去找它获取，这些主机慢慢发展壮大，成了今天的服务端，而其他的主机便是客户端。

*类似于出现了店家，人们不再以物易物，而是去店家那获取资源*

而在Linux中，客户端与服务端之间“交易方式”，如下图所示

![img](imgs/45cdbd6ffe49ef69f0bd70548e9ad2f5.png)

### 主要框架
但很显然，当有多个客户端和服务端发生“交易”时，服务端就得好好设计一番，才能不耽误与各个客户端的“交易”过程。

于是，在服务端内部作好一种最基本的新体系，如下图：

![img](imgs/596ed7d350426b67851b6808c2c2b7dd.png)

I/O处理单元：

- 接受客户连接
- 接收客户数据
- 将处理好的数据还给客户端

请求队列：

- 并非为真正的一个队列，而是一种单元间通信的抽象。
- 当I/O处理单元收到客户请求后，将客户请求交给逻辑单元处理

逻辑单元：

- 通常为一个进程或线程
- 分析客户数据，作出处理
- 将处理结果交给I/O单元（或者直接给客户端）

## 2.I/O模型

服务端与客户端交互的第一棒是I/O，而I/O又可以分为阻塞I/O和非阻塞I/O

### 阻塞I/O、非阻塞I/O、异步I/O

1. 执行方式：
   - 阻塞I/O：应用程序在执行I/O操作时会被阻塞，直到操作完成才能继续执行后续代码。
   - 非阻塞I/O：应用程序执行I/O操作时不会被阻塞，即使操作不能立即完成，函数也会立即返回，应用程序可以继续执行其他任务。
   - 异步I/O：应用程序发起一个I/O操作后，可以继续执行其他任务，而不必等待操作完成。操作完成后，应用程序通过回调函数、信号或事件通知等方式得到通知。
2. 阻塞与非阻塞：
   - 阻塞I/O：在阻塞I/O模型中，当应用程序执行I/O操作时，如果所请求的数据还没有准备好或无法立即写入，操作会被阻塞，应用程序会等待操作完成。
   - 非阻塞I/O：非阻塞I/O模型中，应用程序调用I/O函数时，如果所请求的数据还没有准备好或无法立即写入，函数会立即返回一个错误码，应用程序可以继续执行其他任务。
   - 异步I/O：异步I/O模型中，应用程序发起一个I/O操作后，可以继续执行其他任务，操作的完成与否通过回调函数、信号或事件通知等方式通知应用程序。
3. 应用程序的执行流程：
   - 阻塞I/O：在阻塞I/O模型中，应用程序的执行流程是线性的，按顺序执行每个I/O操作并等待其完成，这可能导致应用程序在等待I/O操作期间无法执行其他任务。
   - 非阻塞I/O：非阻塞I/O模型中，应用程序可以发起多个I/O操作并继续执行其他任务，操作的完成与否通过错误码通知，应用程序需要轮询或使用其他机制来判断是否可以重试操作。
   - 异步I/O：异步I/O模型中，应用程序可以发起多个I/O操作并继续执行其他任务，操作的完成与否通过回调函数、信号或事件通知等方式通知应用程序，从而实现并发执行。
4. 编程复杂性：
   - 阻塞I/O：阻塞I/O模型相对简单，应用程序的代码流程较为直接，但可能需要进行阻塞等待操作完成。
   - 非阻塞I/O：非阻塞I/O模型相对复杂，需要处理错误码和轮询操作状态的逻辑，以便适时重试或等待操作完成。
   - 异步I/O：异步I/O模型相对复杂，需要处理回调函数、事件通知等异步操作的管理和状态，并可能依赖特定的异步I/O接口和函数。

### I/O多路复用

在多路复⽤IO模型中，会有⼀个专⻔的线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调⽤实际的IO读写操作。IO多路复⽤的优势在于，可以处理⼤量并发的IO，⽽不⽤消耗太多CPU/内存。

## 3.两种高效的事件处理模式

将服务器编程的基础框架和几种不同的I/O模型结合一下，就可以得到两种高效的事件处理模式

- Reactor
- Proactor

其中，同步I/O实现Reactor模式，异步I/O实现Proactor模式，但同时可以用同步I/O去模拟出Proactor处理模式

### Reactor

Reactor模式是一种基于事件驱动的模式，常用于实现高并发的服务器应用。它的核心思想是将I/O操作的处理分离为两个关键组件：事件分发器（Event Dispatcher）和事件处理器（Event Handlers）。

- **事件分发器**（通常为主线程，一直处于激活状态）：负责监听和分发事件。它会注册和管理所有的事件，并在事件发生时通知事件处理器进行处理。事件分发器通常采用阻塞I/O模型，使用一个专门的线程或进程来监听和等待事件的到来。
- **事件处理器**（通常为工作线程）：负责具体的事件处理逻辑（接收新的连接、读数据、处理客户请求、写数据）。事件处理器会被注册到事件分发器中，并在事件发生时被调用。它可以是单个线程或线程池中的多个线程，用于并发处理多个事件。

Reactor模式的优点是高并发和可扩展性。通过事件分发器的阻塞I/O模型，可以高效地监听和处理大量的并发事件。并且，事件处理器的并发执行可以充分利用多核系统的性能。

![img](imgs/171acb07a8d81e3eb13984a7ef493d26.png)

注：图中工作线程并不是区分“读工作线程”和“写工作线程”，而是为了逻辑清晰而这样画，Reactor真正运行的过程中，工作线程将自己根据从请求队列取出的事件类型来决定如何处理。

### Proactor

Proactor模式是一种基于异步操作的模式，常用于实现高性能的I/O操作。（只有在读/写就绪之后才能进行数据读/写操作）它的核心思想是将I/O操作的发起和完成分离，通过回调函数或事件通知的方式实现异步操作。

- I/O发起者（Initiator，通常为主线程）：负责发起I/O操作。它会向操作系统或底层的I/O框架发起异步操作请求，并提供一个回调函数或事件处理函数。
- I/O完成者（Completion Handler）：负责具体的I/O操作完成后的处理。当I/O操作完成时，操作系统或底层框架会调用事先注册的回调函数或事件处理函数，通知I/O的完成状态和结果。这样，应用程序可以继续执行其他任务，而不必阻塞等待操作完成。

Proactor模式的优点是高性能和可伸缩性。通过异步操作和回调函数的方式，可以充分利用操作系统或底层框架提供的异步I/O机制，实现高效的I/O处理。应用程序可以发起多个异步操作，并在操作完成后得到通知，从而实现高并发和响应性。

![img](imgs/285fd08ba3cec56d06111808772005c4.png)

 注：主线程中的epoll仅仅用来检测 **监听socket** 上的连接请求事件，不能用来检测 **连接socket** 上的读写事件

## 4.模拟Proactor模式

通过观察可以发现，在Proactor模型中I/O交由内核处理，工作线程不需要进行数据的读写。因此，我们可以用主线程来完成一部分内核的功能来做到模拟Proactor模式。

即：主线程执行数据的读写操作，读写完成后，主线程向工作线程通知读写完成。这样从工作线程来看，就只需进行数据的逻辑操作了。

![img](imgs/63c70895e01641288e581362019ab37b.png)

## 5.半同步/半异步的并发模式

CPU的并发可以显著提升程序的性能（操作系统基础知识），在服务器编程中，一种比较高效常见的并发编程模式是：半同步/半异步模式。

半同步/半异步模式的基本思想是将应用程序的处理逻辑根据需求分成同步任务和异步任务两部分，以提高整体的性能和并发能力。同步层处理那些需要同步、阻塞或顺序执行的任务，而异步层处理那些可以并发执行的、不需要阻塞的任务。

**注意**：这里的同步和异步与前文I/O模型的同步和异步是完全不同的概念。

- 在I/O模型中：
	- 同步：内核向应用程序通知I/O就绪事件，由应用程序（工作线程）完成读写
	- 异步：内核向应用程序通知I/O完成时间，内核自己完成读写

- 在并发模式中：
	- 同步：代码按顺序执行
	- 异步：代码可能受中段，信号等影响，交错地执行

在服务器的设计中，往往采用同步线程处理客户逻辑，异步线程处理I/O事件，这种并发模式结合事件处理模式和I/O模型，即可得到一种称为**半同步/半反应堆(half-sync/half-reactive)模式**从其名字可知，其采用的是Reactor的事件处理模式

![img](imgs/95aa23ac9527e72be3e2539ab097c436.png)

该模式中，只有主线程是是异步线程，工作线程都是同步线程。

**工作流程细节**：主线程监听所有socket上的事件，如有有可读事件发生（新的连接到来），就获取其连接socket，并往epoll内核事件表中注册这个socket上的读写事件，然后将其插入请求队列。工作线程将其从中取出，进行读操作，逻辑处理，写操作等。

**如何将其改成模拟Proactor事件模式**：主线程将socket的中的信息读出封装成一个任务对象，然后将这个任务对象（或指向这个任务对象的指针）插入请求队列，工作线程就只用处理，不必进行I/O操作了。

## 6.有限状态机

前面几节讨论了服务器 **I/O处理单元**，**请求队列**，**逻辑单元**之间协调完成任务的各种模式，现在了解一下在**逻辑单元内部**的一种处理问题的编程方法：有限状态机。

在连接socket的数据被工作线程得到后，可以根据其应用层协议的头部类型字段的类型来进行不同的处理。其中每种不同的字段可以映射成有限状态机内的各种状态，每种状态下编写不同的处理代码。

同时，状态机还需要在不同的状态之间进行转移。

```cpp
{
    State cur_State = typeA; //1.初始状态
    while (cur_State != typeC)
    { //2.当状态变成退出状态typeC时，退出循环
       Package _pack = getNewPackage();
       switch (cur_State)
       {
       case type_A:
          process_package_state_A(_pack);
          cur_State = typeB; //3.切换状态
          break;
       case type_B:
          process_package_state_B(_pack);
          cur_State = typeC; //4.切换到退出状态
          break;
       }
    }
}
```

## 7.其他提高服务器性能的方法

### 池

所谓池是一组资源的集合，这组资源在服务器启动的时候就已经初始化好了，当服务器进入正式运行阶段，需要某些资源，就不需要花费大量时间去动态申请，使用，释放，而直接从池里取出用即可，这就极大提高了服务器的运行效率。

> **池思想面临的困难**：不知道预先应该分配多少资源，应该怎么办？
>
> **解决方法**：
>
> - 分配非常多的资源，在大多数情况下不可能用完（不现实）
> - 根据使用场景预估分配足够多的资源，如果不够用了，可以自动再扩充池

以下是一些使用池来提高服务器性能的常见方法：

1. **线程池**（Thread Pool）：
   在多线程服务器中，可以创建一个线程池来管理和重用线程。当有新的请求到达时，线程池中的空闲线程可以立即处理请求，而不需要每次都创建新线程。这减少了线程创建和销毁的开销，并提高了服务器的并发处理能力。
2. **进程池**（Process Pool）：
   在多进程服务器中，可以创建一个进程池来管理和重用进程。类似于线程池，进程池可以避免频繁创建和销毁进程的开销，从而提高服务器的并发能力。每个进程可以独立地处理请求，从而实现并行处理。
3. **连接池**（Connection Pool）：
   对于数据库服务器或其他需要建立连接的资源，可以使用连接池来管理和重用连接。连接池会预先创建一些连接，并将它们保存在池中。当需要使用连接时，可以从池中获取一个空闲连接，并在使用完成后将其返回到池中，而不是每次都建立新的连接。这降低了连接创建和销毁的开销，并提高了数据库访问的性能。
4. **缓存池**（Cache Pool）：
   在服务器中，可以使用缓存池来管理和重用计算结果、查询结果或其他经常使用的数据。通过将数据缓存在内存中，可以避免频繁的计算或数据库查询操作，从而提高响应时间和吞吐量。
5. **对象池**（Object Pool）：
   对于某些需要频繁创建和销毁的对象，可以使用对象池来管理和重用这些对象。对象池会预先创建一些对象，并将它们保存在池中。当需要使用对象时，可以从池中获取一个空闲对象，并在使用完成后将其返回到池中，而不是每次都创建新的对象。这减少了对象创建和销毁的开销，并提高了服务器的性能。

### 数据复制

高性能服务器应该避免不必要的数据复制操作，且要善用零拷贝，共享内存等方式。

例如：FTP服务器，当客户请求一个文件时，服务器只需要检测目标文件是否存在，用户是否有读取它的权限即可，不必关心文件内的内容。所以FTP服务器无需将目标文件的内容完整地读到应用程序缓冲区中并调用send来进行发送，而是可以直接使用“零拷贝”函数send将其直接发给客户端。

### 上下文切换和锁

在web服务器地模型中，不可能为每一个客户连接都创建一个工作线程，因为这样会创建非常多的工作线程，而CPU的数量是有限的。

而CPU在并发的工作模式下，会在不同的线程之间进行切换，这种切换会消耗CPU资源，而处理业务逻辑的时间就会减少，如果线程太多，CPU就会频繁切换上下文而真正有意义的工作将大大减少。

提高服务器运行效率的其中一个重要方法是共享内存，但共享内存同时也会带来许多安全隐患问题，为了防止这些隐患，需要使用锁。而锁也会占用一定的系统资源，这种时候需要考虑使用粒度更小的锁，如读写锁等来提高性能。

